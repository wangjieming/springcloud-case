### 上面一讲聊到了Spring Cloud的服务提供者，看起来跟Spring Boot没有什么两样。
### 这样需要彻底搞清楚，Spring Boot和Spring Cloud有什么本质的差别和联系？
### 其实，Spring Boot，就是一个很方便的后端服务框架，Java EE的老开发者应该用过serverlet，在没有Spring框架出现之前，我们用的就是serverlet，很简单，但是也真的非常不方便，需要个定时器，那就自己写一个呗，需要一个单例，自己写一个吧，同时还研究一下单例的几种写法，需要连MySQL，可以啊，自己写JDBC，然后自己找MySQL驱动呗，需要Redis或者其他组件，就到处各组件的官网找jar包，然后不断解决版本冲突，这些事情，都很消耗一个程序员都耐心，到了Spring Boot时代的时候，很多常用的组件都被做成starter，就是一个只包含pom.xml的jar包，只需要maven引用一下，这些jar都包含进来了，而且版本冲突也真的少了很多，单例，回调，定时器，甚至拦截器等等之前很多在severlet时代需要自己手工写的东西，就变成一两行注解就可以解决的问题。你说爽不爽？ 有了Spring Boot，基本你要的后端服务功能都有了，为什么还要搞个Spring Cloud出来？

### 这个问题，你可以问问曹操，当年赤壁之战的时候，明明都已经有战船了，为什么还要用铁索把战船连起来，然后被蜀吴一把火烧了。

### 其实，Spring Boot可以比作一只小小的战船，而Spring Cloud就是把战船连起来的铁索。

### Spring Cloud这样做，是有深刻的发展原因的。你可以想想，单机的微服务，如果是小企业网站，每天加上老板那个必然的点击，一共可能也就十个八个点击，你怎么搞都可以，但是，当你面对的是上百万，上千万的用户，单机服务就非常吃力了。

### 首先，当业务发展得非常庞大的时候，业务需要扩容，你怎么扩？

### 以前在Spring Boot微服务时代，一般后端服务和客户端之间，会有一层nginx做网关转发，增加一台机器，nginx就配置一下转发，但是，到了Spring Cloud时代，没有这个必要了，机器需要扩容？直接部署一个服务，然后把服务注册到注册中心（比如zookeeper），服务启动后，马上就会被发现。然后消费者端就可以直接调用了。

### 现在知道zookeeper的作用了吗？他作为Spring Cloud服务的中心，扮演着一个知心大姐（当然，zookeeper也可以是集群的，应该说是一群知心大姐）角色，一个服务提供者启动了，告诉zookeeper这个知心大姐（注册），然后消费者跟zookeeper也是有连接，会很快知道有新的服务提供者启动了，流量可以分一点到新的服务提供者，这样，等于一堆服务提供者都连结在一起了，都在承担流量。

### 那么，问题来了，一群服务提供者都在承担流量，但是，机器配置可能各有差异，哪台承担多一些，哪台少一些？这个就需要有一个角色来承担流量均衡了，谁能承担这个角色？Ribbon或者Feign都可以，这两个角色将来可以怎么分配流量，有哪些算法，有什么特性？我们后面再说。

### 然后，问题又来了，流量越来越大，有的接口流量实在打到服务器都顶不住了，为了不让所有接口一块儿挂，只能进行服务降级了，什么叫服务降级？就是把某些服务直接关闭，不提供服务了，这个角色叫熔断器，Hystrix可以承担这个任务。熔断器相当于家中的保险丝，用了它，可以防止所有的服务一起雪崩。

### 还有，比如说，如果你项目有些配置需要变动了，之前我们很多时候就是直接改配置文件，然后重启服务。当然，这样做也可以，但是，多少会对用户有些影响，如果你用Spirng Cloud的配置

